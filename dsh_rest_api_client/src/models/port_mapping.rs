/*
 * DSH Tenant Resource Management REST API
 *
 * Resource management API for DSH
 *
 * The version of the OpenAPI document: 1.7.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct PortMapping {
    /// TODO
    #[serde(rename = "auth", skip_serializing_if = "Option::is_none")]
    pub auth: Option<String>,
    /// Routing mode. The allowed values are:   * `http` (default if this property is omitted). HTTP routing and TLS termination are done by the platform. In this case, the `tls` and (optionally) `paths` settings should be configured as well.   * `tcp/<endpoint>`. The platform only does plain TCP routing, with TLS pass-through. When set, the `tls` and `paths` settings are ignored. The application is responsible for TLS termination and certificate management. There are various possible values for `<endpoint>` that may appear when listing allocation configurations, but the only value that is allowed to be set in regular application allocations is `tcp/https`.     * `tcp/https`. Any traffic arriving on `<vhost>:443` will be forwarded (TLS included) to the service.     * `tcp/kafka-proxy` is used by Kafka Proxies. This endpoint is auto-configured by the platform when allocating a Kafka Proxy application and should *not* be used when allocating regular applications.     * `tcp/vpn-tcp` is used by a VPN application. This endpoint is auto-configured by the platform when allocating a VPN application and should *not* be used when allocating regular applications.
    #[serde(rename = "mode", skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// The paths which are allowed on the associated vhost
    #[serde(rename = "paths", skip_serializing_if = "Option::is_none")]
    pub paths: Option<Vec<models::PathSpec>>,
    /// The default is 'auto', indicating that the port will only accept secured connections. Put this to 'none' if you do not want the service to have a secure endpoint.
    #[serde(rename = "tls", skip_serializing_if = "Option::is_none")]
    pub tls: Option<Tls>,
    /// The host name that needs to be assigned to this port (for multiple names, separate them with commas)
    #[serde(rename = "vhost", skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
    /// Put ip addresses or ip ranges that can call this service here (for multiple addresses, separate them with spaces)
    #[serde(rename = "whitelist", skip_serializing_if = "Option::is_none")]
    pub whitelist: Option<String>,
    /// To load balance traffic between different services, use this optional field to put those services in the same service group. Choose any name consisting of all lowercase letters.
    #[serde(rename = "serviceGroup", skip_serializing_if = "Option::is_none")]
    pub service_group: Option<String>,
}

impl PortMapping {
    pub fn new() -> PortMapping {
        PortMapping {
            auth: None,
            mode: None,
            paths: None,
            tls: None,
            vhost: None,
            whitelist: None,
            service_group: None,
        }
    }
}
/// The default is 'auto', indicating that the port will only accept secured connections. Put this to 'none' if you do not want the service to have a secure endpoint.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Tls {
    #[serde(rename = "auto")]
    Auto,
    #[serde(rename = "none")]
    None,
}

impl Default for Tls {
    fn default() -> Tls {
        Self::Auto
    }
}
